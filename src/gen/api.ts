/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * E-commerce API
 * API para e-commerce
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  AddToCartDto,
  Address,
  CreateAddressDto,
  CreateCardDto,
  CreateCustomerDto,
  CreateOrderDto,
  CreateUserDto,
  LoginDto,
  LoginResponseDto,
  ProductControllerFindAllParams,
  UpdateAddressDto,
  UpdateCartItemDto,
  UpdateUserDto,
  User,
  UserControllerFindAll200,
  UserControllerFindAllParams
} from './types';

import { http } from '../services/api';
import type { ErrorType , BodyType } from '../services/api';
type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



export const authControllerLogin = (
    loginDto: BodyType<LoginDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<LoginResponseDto>(
      {url: `http://localhost:3000/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: loginDto, signal
    },
      options);
    }
  


export const getAuthControllerLoginMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: BodyType<LoginDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: BodyType<LoginDto>}, TContext> => {

const mutationKey = ['authControllerLogin'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authControllerLogin>>, {data: BodyType<LoginDto>}> = (props) => {
          const {data} = props ?? {};

          return  authControllerLogin(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthControllerLoginMutationResult = NonNullable<Awaited<ReturnType<typeof authControllerLogin>>>
    export type AuthControllerLoginMutationBody = BodyType<LoginDto>
    export type AuthControllerLoginMutationError = ErrorType<unknown>

    export const useAuthControllerLogin = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authControllerLogin>>, TError,{data: BodyType<LoginDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authControllerLogin>>,
        TError,
        {data: BodyType<LoginDto>},
        TContext
      > => {

      const mutationOptions = getAuthControllerLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const userControllerCreate = (
    createUserDto: BodyType<CreateUserDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/users`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createUserDto, signal
    },
      options);
    }
  


export const getUserControllerCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: BodyType<CreateUserDto>}, TContext> => {

const mutationKey = ['userControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerCreate>>, {data: BodyType<CreateUserDto>}> = (props) => {
          const {data} = props ?? {};

          return  userControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerCreate>>>
    export type UserControllerCreateMutationBody = BodyType<CreateUserDto>
    export type UserControllerCreateMutationError = ErrorType<unknown>

    export const useUserControllerCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerCreate>>, TError,{data: BodyType<CreateUserDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerCreate>>,
        TError,
        {data: BodyType<CreateUserDto>},
        TContext
      > => {

      const mutationOptions = getUserControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const userControllerFindAll = (
    params?: UserControllerFindAllParams,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<UserControllerFindAll200>(
      {url: `http://localhost:3000/users`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getUserControllerFindAllQueryKey = (params?: UserControllerFindAllParams,) => {
    return [
    `http://localhost:3000/users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getUserControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof userControllerFindAll>>, TError = ErrorType<unknown>>(params?: UserControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindAll>>> = ({ signal }) => userControllerFindAll(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindAll>>>
export type UserControllerFindAllQueryError = ErrorType<unknown>


export function useUserControllerFindAll<TData = Awaited<ReturnType<typeof userControllerFindAll>>, TError = ErrorType<unknown>>(
 params: undefined |  UserControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerFindAll<TData = Awaited<ReturnType<typeof userControllerFindAll>>, TError = ErrorType<unknown>>(
 params?: UserControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerFindAll<TData = Awaited<ReturnType<typeof userControllerFindAll>>, TError = ErrorType<unknown>>(
 params?: UserControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerFindAll<TData = Awaited<ReturnType<typeof userControllerFindAll>>, TError = ErrorType<unknown>>(
 params?: UserControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const userControllerFindOne = (
    id: string,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<User>(
      {url: `http://localhost:3000/users/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getUserControllerFindOneQueryKey = (id?: string,) => {
    return [
    `http://localhost:3000/users/${id}`
    ] as const;
    }

    
export const getUserControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof userControllerFindOne>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) => userControllerFindOne(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerFindOne>>>
export type UserControllerFindOneQueryError = ErrorType<unknown>


export function useUserControllerFindOne<TData = Awaited<ReturnType<typeof userControllerFindOne>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerFindOne<TData = Awaited<ReturnType<typeof userControllerFindOne>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerFindOne<TData = Awaited<ReturnType<typeof userControllerFindOne>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerFindOne<TData = Awaited<ReturnType<typeof userControllerFindOne>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerFindOneQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




export const userControllerUpdate = (
    id: string,
    updateUserDto: BodyType<UpdateUserDto>,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<User>(
      {url: `http://localhost:3000/users/${id}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateUserDto
    },
      options);
    }
  


export const getUserControllerUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: BodyType<UpdateUserDto>}, TContext> => {

const mutationKey = ['userControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerUpdate>>, {id: string;data: BodyType<UpdateUserDto>}> = (props) => {
          const {id,data} = props ?? {};

          return  userControllerUpdate(id,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerUpdate>>>
    export type UserControllerUpdateMutationBody = BodyType<UpdateUserDto>
    export type UserControllerUpdateMutationError = ErrorType<unknown>

    export const useUserControllerUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerUpdate>>, TError,{id: string;data: BodyType<UpdateUserDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerUpdate>>,
        TError,
        {id: string;data: BodyType<UpdateUserDto>},
        TContext
      > => {

      const mutationOptions = getUserControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const userControllerDestroy = (
    id: string,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/users/${id}`, method: 'DELETE'
    },
      options);
    }
  


export const getUserControllerDestroyMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof userControllerDestroy>>, TError,{id: string}, TContext> => {

const mutationKey = ['userControllerDestroy'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userControllerDestroy>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  userControllerDestroy(id,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserControllerDestroyMutationResult = NonNullable<Awaited<ReturnType<typeof userControllerDestroy>>>
    
    export type UserControllerDestroyMutationError = ErrorType<unknown>

    export const useUserControllerDestroy = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userControllerDestroy>>, TError,{id: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof userControllerDestroy>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getUserControllerDestroyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const userControllerGetMe = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<User>(
      {url: `http://localhost:3000/users/me`, method: 'GET', signal
    },
      options);
    }
  



export const getUserControllerGetMeQueryKey = () => {
    return [
    `http://localhost:3000/users/me`
    ] as const;
    }

    
export const getUserControllerGetMeQueryOptions = <TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUserControllerGetMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetMe>>> = ({ signal }) => userControllerGetMe(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UserControllerGetMeQueryResult = NonNullable<Awaited<ReturnType<typeof userControllerGetMe>>>
export type UserControllerGetMeQueryError = ErrorType<unknown>


export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetMe>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetMe>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useUserControllerGetMe<TData = Awaited<ReturnType<typeof userControllerGetMe>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userControllerGetMe>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserControllerGetMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Criar novo endere√ßo
 */
export const addressControllerCreate = (
    createAddressDto: BodyType<CreateAddressDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<Address>(
      {url: `http://localhost:3000/addresses`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createAddressDto, signal
    },
      options);
    }
  


export const getAddressControllerCreateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerCreate>>, TError,{data: BodyType<CreateAddressDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof addressControllerCreate>>, TError,{data: BodyType<CreateAddressDto>}, TContext> => {

const mutationKey = ['addressControllerCreate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressControllerCreate>>, {data: BodyType<CreateAddressDto>}> = (props) => {
          const {data} = props ?? {};

          return  addressControllerCreate(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressControllerCreateMutationResult = NonNullable<Awaited<ReturnType<typeof addressControllerCreate>>>
    export type AddressControllerCreateMutationBody = BodyType<CreateAddressDto>
    export type AddressControllerCreateMutationError = ErrorType<unknown>

    /**
 * @summary Criar novo endere√ßo
 */
export const useAddressControllerCreate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerCreate>>, TError,{data: BodyType<CreateAddressDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressControllerCreate>>,
        TError,
        {data: BodyType<CreateAddressDto>},
        TContext
      > => {

      const mutationOptions = getAddressControllerCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Listar endere√ßos do usu√°rio
 */
export const addressControllerFindAll = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<Address[]>(
      {url: `http://localhost:3000/addresses`, method: 'GET', signal
    },
      options);
    }
  



export const getAddressControllerFindAllQueryKey = () => {
    return [
    `http://localhost:3000/addresses`
    ] as const;
    }

    
export const getAddressControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof addressControllerFindAll>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressControllerFindAllQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressControllerFindAll>>> = ({ signal }) => addressControllerFindAll(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof addressControllerFindAll>>>
export type AddressControllerFindAllQueryError = ErrorType<unknown>


export function useAddressControllerFindAll<TData = Awaited<ReturnType<typeof addressControllerFindAll>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindAll<TData = Awaited<ReturnType<typeof addressControllerFindAll>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindAll<TData = Awaited<ReturnType<typeof addressControllerFindAll>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar endere√ßos do usu√°rio
 */

export function useAddressControllerFindAll<TData = Awaited<ReturnType<typeof addressControllerFindAll>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressControllerFindAllQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Buscar endere√ßo padr√£o do usu√°rio
 */
export const addressControllerFindDefault = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<Address>(
      {url: `http://localhost:3000/addresses/default`, method: 'GET', signal
    },
      options);
    }
  



export const getAddressControllerFindDefaultQueryKey = () => {
    return [
    `http://localhost:3000/addresses/default`
    ] as const;
    }

    
export const getAddressControllerFindDefaultQueryOptions = <TData = Awaited<ReturnType<typeof addressControllerFindDefault>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressControllerFindDefaultQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressControllerFindDefault>>> = ({ signal }) => addressControllerFindDefault(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressControllerFindDefaultQueryResult = NonNullable<Awaited<ReturnType<typeof addressControllerFindDefault>>>
export type AddressControllerFindDefaultQueryError = ErrorType<unknown>


export function useAddressControllerFindDefault<TData = Awaited<ReturnType<typeof addressControllerFindDefault>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindDefault>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindDefault>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindDefault<TData = Awaited<ReturnType<typeof addressControllerFindDefault>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindDefault>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindDefault>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindDefault<TData = Awaited<ReturnType<typeof addressControllerFindDefault>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar endere√ßo padr√£o do usu√°rio
 */

export function useAddressControllerFindDefault<TData = Awaited<ReturnType<typeof addressControllerFindDefault>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindDefault>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressControllerFindDefaultQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Buscar endere√ßo por ID
 */
export const addressControllerFindOne = (
    addressId: string,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<Address>(
      {url: `http://localhost:3000/addresses/${addressId}`, method: 'GET', signal
    },
      options);
    }
  



export const getAddressControllerFindOneQueryKey = (addressId?: string,) => {
    return [
    `http://localhost:3000/addresses/${addressId}`
    ] as const;
    }

    
export const getAddressControllerFindOneQueryOptions = <TData = Awaited<ReturnType<typeof addressControllerFindOne>>, TError = ErrorType<unknown>>(addressId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAddressControllerFindOneQueryKey(addressId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof addressControllerFindOne>>> = ({ signal }) => addressControllerFindOne(addressId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(addressId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AddressControllerFindOneQueryResult = NonNullable<Awaited<ReturnType<typeof addressControllerFindOne>>>
export type AddressControllerFindOneQueryError = ErrorType<unknown>


export function useAddressControllerFindOne<TData = Awaited<ReturnType<typeof addressControllerFindOne>>, TError = ErrorType<unknown>>(
 addressId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindOne<TData = Awaited<ReturnType<typeof addressControllerFindOne>>, TError = ErrorType<unknown>>(
 addressId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof addressControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof addressControllerFindOne>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAddressControllerFindOne<TData = Awaited<ReturnType<typeof addressControllerFindOne>>, TError = ErrorType<unknown>>(
 addressId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar endere√ßo por ID
 */

export function useAddressControllerFindOne<TData = Awaited<ReturnType<typeof addressControllerFindOne>>, TError = ErrorType<unknown>>(
 addressId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof addressControllerFindOne>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAddressControllerFindOneQueryOptions(addressId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Atualizar endere√ßo
 */
export const addressControllerUpdate = (
    addressId: string,
    updateAddressDto: BodyType<UpdateAddressDto>,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<Address>(
      {url: `http://localhost:3000/addresses/${addressId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: updateAddressDto
    },
      options);
    }
  


export const getAddressControllerUpdateMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerUpdate>>, TError,{addressId: string;data: BodyType<UpdateAddressDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof addressControllerUpdate>>, TError,{addressId: string;data: BodyType<UpdateAddressDto>}, TContext> => {

const mutationKey = ['addressControllerUpdate'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressControllerUpdate>>, {addressId: string;data: BodyType<UpdateAddressDto>}> = (props) => {
          const {addressId,data} = props ?? {};

          return  addressControllerUpdate(addressId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressControllerUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof addressControllerUpdate>>>
    export type AddressControllerUpdateMutationBody = BodyType<UpdateAddressDto>
    export type AddressControllerUpdateMutationError = ErrorType<unknown>

    /**
 * @summary Atualizar endere√ßo
 */
export const useAddressControllerUpdate = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerUpdate>>, TError,{addressId: string;data: BodyType<UpdateAddressDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressControllerUpdate>>,
        TError,
        {addressId: string;data: BodyType<UpdateAddressDto>},
        TContext
      > => {

      const mutationOptions = getAddressControllerUpdateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remover endere√ßo
 */
export const addressControllerDelete = (
    addressId: string,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/addresses/${addressId}`, method: 'DELETE'
    },
      options);
    }
  


export const getAddressControllerDeleteMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerDelete>>, TError,{addressId: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof addressControllerDelete>>, TError,{addressId: string}, TContext> => {

const mutationKey = ['addressControllerDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressControllerDelete>>, {addressId: string}> = (props) => {
          const {addressId} = props ?? {};

          return  addressControllerDelete(addressId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressControllerDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof addressControllerDelete>>>
    
    export type AddressControllerDeleteMutationError = ErrorType<unknown>

    /**
 * @summary Remover endere√ßo
 */
export const useAddressControllerDelete = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerDelete>>, TError,{addressId: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressControllerDelete>>,
        TError,
        {addressId: string},
        TContext
      > => {

      const mutationOptions = getAddressControllerDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Definir endere√ßo como padr√£o
 */
export const addressControllerSetDefault = (
    addressId: string,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<Address>(
      {url: `http://localhost:3000/addresses/${addressId}/set-default`, method: 'PATCH'
    },
      options);
    }
  


export const getAddressControllerSetDefaultMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerSetDefault>>, TError,{addressId: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof addressControllerSetDefault>>, TError,{addressId: string}, TContext> => {

const mutationKey = ['addressControllerSetDefault'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof addressControllerSetDefault>>, {addressId: string}> = (props) => {
          const {addressId} = props ?? {};

          return  addressControllerSetDefault(addressId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AddressControllerSetDefaultMutationResult = NonNullable<Awaited<ReturnType<typeof addressControllerSetDefault>>>
    
    export type AddressControllerSetDefaultMutationError = ErrorType<unknown>

    /**
 * @summary Definir endere√ßo como padr√£o
 */
export const useAddressControllerSetDefault = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof addressControllerSetDefault>>, TError,{addressId: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof addressControllerSetDefault>>,
        TError,
        {addressId: string},
        TContext
      > => {

      const mutationOptions = getAddressControllerSetDefaultMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Criar ou obter cliente Pagar.me
 */
export const paymentControllerCreateCustomer = (
    createCustomerDto: BodyType<CreateCustomerDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/customer`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCustomerDto, signal
    },
      options);
    }
  


export const getPaymentControllerCreateCustomerMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCustomer>>, TError,{data: BodyType<CreateCustomerDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCustomer>>, TError,{data: BodyType<CreateCustomerDto>}, TContext> => {

const mutationKey = ['paymentControllerCreateCustomer'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerCreateCustomer>>, {data: BodyType<CreateCustomerDto>}> = (props) => {
          const {data} = props ?? {};

          return  paymentControllerCreateCustomer(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerCreateCustomerMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerCreateCustomer>>>
    export type PaymentControllerCreateCustomerMutationBody = BodyType<CreateCustomerDto>
    export type PaymentControllerCreateCustomerMutationError = ErrorType<unknown>

    /**
 * @summary Criar ou obter cliente Pagar.me
 */
export const usePaymentControllerCreateCustomer = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCustomer>>, TError,{data: BodyType<CreateCustomerDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerCreateCustomer>>,
        TError,
        {data: BodyType<CreateCustomerDto>},
        TContext
      > => {

      const mutationOptions = getPaymentControllerCreateCustomerMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Buscar dados do cliente
 */
export const paymentControllerGetCustomer = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/customer`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetCustomerQueryKey = () => {
    return [
    `http://localhost:3000/payment/customer`
    ] as const;
    }

    
export const getPaymentControllerGetCustomerQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetCustomerQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetCustomer>>> = ({ signal }) => paymentControllerGetCustomer(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetCustomerQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetCustomer>>>
export type PaymentControllerGetCustomerQueryError = ErrorType<unknown>


export function usePaymentControllerGetCustomer<TData = Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCustomer>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCustomer<TData = Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCustomer>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCustomer>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCustomer<TData = Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar dados do cliente
 */

export function usePaymentControllerGetCustomer<TData = Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCustomer>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetCustomerQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Adicionar cart√£o de cr√©dito
 */
export const paymentControllerCreateCard = (
    createCardDto: BodyType<CreateCardDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cards`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createCardDto, signal
    },
      options);
    }
  


export const getPaymentControllerCreateCardMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCard>>, TError,{data: BodyType<CreateCardDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCard>>, TError,{data: BodyType<CreateCardDto>}, TContext> => {

const mutationKey = ['paymentControllerCreateCard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerCreateCard>>, {data: BodyType<CreateCardDto>}> = (props) => {
          const {data} = props ?? {};

          return  paymentControllerCreateCard(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerCreateCardMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerCreateCard>>>
    export type PaymentControllerCreateCardMutationBody = BodyType<CreateCardDto>
    export type PaymentControllerCreateCardMutationError = ErrorType<unknown>

    /**
 * @summary Adicionar cart√£o de cr√©dito
 */
export const usePaymentControllerCreateCard = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateCard>>, TError,{data: BodyType<CreateCardDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerCreateCard>>,
        TError,
        {data: BodyType<CreateCardDto>},
        TContext
      > => {

      const mutationOptions = getPaymentControllerCreateCardMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Listar cart√µes do usu√°rio
 */
export const paymentControllerGetCards = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cards`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetCardsQueryKey = () => {
    return [
    `http://localhost:3000/payment/cards`
    ] as const;
    }

    
export const getPaymentControllerGetCardsQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetCards>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetCardsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetCards>>> = ({ signal }) => paymentControllerGetCards(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetCardsQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetCards>>>
export type PaymentControllerGetCardsQueryError = ErrorType<unknown>


export function usePaymentControllerGetCards<TData = Awaited<ReturnType<typeof paymentControllerGetCards>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCards>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCards<TData = Awaited<ReturnType<typeof paymentControllerGetCards>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCards>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCards>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCards<TData = Awaited<ReturnType<typeof paymentControllerGetCards>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar cart√µes do usu√°rio
 */

export function usePaymentControllerGetCards<TData = Awaited<ReturnType<typeof paymentControllerGetCards>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCards>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetCardsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Remover cart√£o de cr√©dito
 */
export const paymentControllerDeleteCard = (
    cardId: string,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cards/${cardId}`, method: 'DELETE'
    },
      options);
    }
  


export const getPaymentControllerDeleteCardMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerDeleteCard>>, TError,{cardId: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerDeleteCard>>, TError,{cardId: string}, TContext> => {

const mutationKey = ['paymentControllerDeleteCard'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerDeleteCard>>, {cardId: string}> = (props) => {
          const {cardId} = props ?? {};

          return  paymentControllerDeleteCard(cardId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerDeleteCardMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerDeleteCard>>>
    
    export type PaymentControllerDeleteCardMutationError = ErrorType<unknown>

    /**
 * @summary Remover cart√£o de cr√©dito
 */
export const usePaymentControllerDeleteCard = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerDeleteCard>>, TError,{cardId: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerDeleteCard>>,
        TError,
        {cardId: string},
        TContext
      > => {

      const mutationOptions = getPaymentControllerDeleteCardMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Adicionar produto ao carrinho
 */
export const paymentControllerAddToCart = (
    addToCartDto: BodyType<AddToCartDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: addToCartDto, signal
    },
      options);
    }
  


export const getPaymentControllerAddToCartMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerAddToCart>>, TError,{data: BodyType<AddToCartDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerAddToCart>>, TError,{data: BodyType<AddToCartDto>}, TContext> => {

const mutationKey = ['paymentControllerAddToCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerAddToCart>>, {data: BodyType<AddToCartDto>}> = (props) => {
          const {data} = props ?? {};

          return  paymentControllerAddToCart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerAddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerAddToCart>>>
    export type PaymentControllerAddToCartMutationBody = BodyType<AddToCartDto>
    export type PaymentControllerAddToCartMutationError = ErrorType<unknown>

    /**
 * @summary Adicionar produto ao carrinho
 */
export const usePaymentControllerAddToCart = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerAddToCart>>, TError,{data: BodyType<AddToCartDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerAddToCart>>,
        TError,
        {data: BodyType<AddToCartDto>},
        TContext
      > => {

      const mutationOptions = getPaymentControllerAddToCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Listar itens do carrinho
 */
export const paymentControllerGetCart = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetCartQueryKey = () => {
    return [
    `http://localhost:3000/payment/cart`
    ] as const;
    }

    
export const getPaymentControllerGetCartQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetCart>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetCartQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetCart>>> = ({ signal }) => paymentControllerGetCart(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetCartQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetCart>>>
export type PaymentControllerGetCartQueryError = ErrorType<unknown>


export function usePaymentControllerGetCart<TData = Awaited<ReturnType<typeof paymentControllerGetCart>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCart>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCart>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCart<TData = Awaited<ReturnType<typeof paymentControllerGetCart>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCart>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCart>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCart<TData = Awaited<ReturnType<typeof paymentControllerGetCart>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar itens do carrinho
 */

export function usePaymentControllerGetCart<TData = Awaited<ReturnType<typeof paymentControllerGetCart>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCart>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetCartQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Limpar carrinho
 */
export const paymentControllerClearCart = (
    
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart`, method: 'DELETE'
    },
      options);
    }
  


export const getPaymentControllerClearCartMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerClearCart>>, TError,void, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerClearCart>>, TError,void, TContext> => {

const mutationKey = ['paymentControllerClearCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerClearCart>>, void> = () => {
          

          return  paymentControllerClearCart(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerClearCartMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerClearCart>>>
    
    export type PaymentControllerClearCartMutationError = ErrorType<unknown>

    /**
 * @summary Limpar carrinho
 */
export const usePaymentControllerClearCart = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerClearCart>>, TError,void, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerClearCart>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPaymentControllerClearCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Obter total do carrinho
 */
export const paymentControllerGetCartTotal = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart/total`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetCartTotalQueryKey = () => {
    return [
    `http://localhost:3000/payment/cart/total`
    ] as const;
    }

    
export const getPaymentControllerGetCartTotalQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetCartTotalQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>> = ({ signal }) => paymentControllerGetCartTotal(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetCartTotalQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>>
export type PaymentControllerGetCartTotalQueryError = ErrorType<unknown>


export function usePaymentControllerGetCartTotal<TData = Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCartTotal>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCartTotal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCartTotal<TData = Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetCartTotal>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetCartTotal>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetCartTotal<TData = Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Obter total do carrinho
 */

export function usePaymentControllerGetCartTotal<TData = Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetCartTotal>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetCartTotalQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Atualizar quantidade de item no carrinho
 */
export const paymentControllerUpdateCartItem = (
    cartItemId: string,
    updateCartItemDto: BodyType<UpdateCartItemDto>,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart/${cartItemId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: updateCartItemDto
    },
      options);
    }
  


export const getPaymentControllerUpdateCartItemMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>, TError,{cartItemId: string;data: BodyType<UpdateCartItemDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>, TError,{cartItemId: string;data: BodyType<UpdateCartItemDto>}, TContext> => {

const mutationKey = ['paymentControllerUpdateCartItem'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>, {cartItemId: string;data: BodyType<UpdateCartItemDto>}> = (props) => {
          const {cartItemId,data} = props ?? {};

          return  paymentControllerUpdateCartItem(cartItemId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerUpdateCartItemMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>>
    export type PaymentControllerUpdateCartItemMutationBody = BodyType<UpdateCartItemDto>
    export type PaymentControllerUpdateCartItemMutationError = ErrorType<unknown>

    /**
 * @summary Atualizar quantidade de item no carrinho
 */
export const usePaymentControllerUpdateCartItem = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>, TError,{cartItemId: string;data: BodyType<UpdateCartItemDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerUpdateCartItem>>,
        TError,
        {cartItemId: string;data: BodyType<UpdateCartItemDto>},
        TContext
      > => {

      const mutationOptions = getPaymentControllerUpdateCartItemMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Remover item do carrinho
 */
export const paymentControllerRemoveFromCart = (
    cartItemId: string,
 options?: SecondParameter<typeof http>,) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/cart/${cartItemId}`, method: 'DELETE'
    },
      options);
    }
  


export const getPaymentControllerRemoveFromCartMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>, TError,{cartItemId: string}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>, TError,{cartItemId: string}, TContext> => {

const mutationKey = ['paymentControllerRemoveFromCart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>, {cartItemId: string}> = (props) => {
          const {cartItemId} = props ?? {};

          return  paymentControllerRemoveFromCart(cartItemId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerRemoveFromCartMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>>
    
    export type PaymentControllerRemoveFromCartMutationError = ErrorType<unknown>

    /**
 * @summary Remover item do carrinho
 */
export const usePaymentControllerRemoveFromCart = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>, TError,{cartItemId: string}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerRemoveFromCart>>,
        TError,
        {cartItemId: string},
        TContext
      > => {

      const mutationOptions = getPaymentControllerRemoveFromCartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Criar pedido e processar pagamento
 */
export const paymentControllerCreateOrder = (
    createOrderDto: BodyType<CreateOrderDto>,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: createOrderDto, signal
    },
      options);
    }
  


export const getPaymentControllerCreateOrderMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateOrder>>, TError,{data: BodyType<CreateOrderDto>}, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateOrder>>, TError,{data: BodyType<CreateOrderDto>}, TContext> => {

const mutationKey = ['paymentControllerCreateOrder'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerCreateOrder>>, {data: BodyType<CreateOrderDto>}> = (props) => {
          const {data} = props ?? {};

          return  paymentControllerCreateOrder(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerCreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerCreateOrder>>>
    export type PaymentControllerCreateOrderMutationBody = BodyType<CreateOrderDto>
    export type PaymentControllerCreateOrderMutationError = ErrorType<unknown>

    /**
 * @summary Criar pedido e processar pagamento
 */
export const usePaymentControllerCreateOrder = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerCreateOrder>>, TError,{data: BodyType<CreateOrderDto>}, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerCreateOrder>>,
        TError,
        {data: BodyType<CreateOrderDto>},
        TContext
      > => {

      const mutationOptions = getPaymentControllerCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Listar pedidos do usu√°rio
 */
export const paymentControllerGetOrders = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/orders`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetOrdersQueryKey = () => {
    return [
    `http://localhost:3000/payment/orders`
    ] as const;
    }

    
export const getPaymentControllerGetOrdersQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError = ErrorType<unknown>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetOrders>>> = ({ signal }) => paymentControllerGetOrders(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetOrders>>>
export type PaymentControllerGetOrdersQueryError = ErrorType<unknown>


export function usePaymentControllerGetOrders<TData = Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError = ErrorType<unknown>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetOrders>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetOrders<TData = Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetOrders>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetOrders>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetOrders<TData = Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar pedidos do usu√°rio
 */

export function usePaymentControllerGetOrders<TData = Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError = ErrorType<unknown>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrders>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetOrdersQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Buscar pedido por ID
 */
export const paymentControllerGetOrder = (
    orderId: string,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/orders/${orderId}`, method: 'GET', signal
    },
      options);
    }
  



export const getPaymentControllerGetOrderQueryKey = (orderId?: string,) => {
    return [
    `http://localhost:3000/payment/orders/${orderId}`
    ] as const;
    }

    
export const getPaymentControllerGetOrderQueryOptions = <TData = Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError = ErrorType<unknown>>(orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getPaymentControllerGetOrderQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof paymentControllerGetOrder>>> = ({ signal }) => paymentControllerGetOrder(orderId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type PaymentControllerGetOrderQueryResult = NonNullable<Awaited<ReturnType<typeof paymentControllerGetOrder>>>
export type PaymentControllerGetOrderQueryError = ErrorType<unknown>


export function usePaymentControllerGetOrder<TData = Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError = ErrorType<unknown>>(
 orderId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetOrder>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetOrder>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetOrder<TData = Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError = ErrorType<unknown>>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof paymentControllerGetOrder>>,
          TError,
          Awaited<ReturnType<typeof paymentControllerGetOrder>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function usePaymentControllerGetOrder<TData = Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError = ErrorType<unknown>>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar pedido por ID
 */

export function usePaymentControllerGetOrder<TData = Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError = ErrorType<unknown>>(
 orderId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof paymentControllerGetOrder>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPaymentControllerGetOrderQueryOptions(orderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Receber notifica√ß√µes de webhook do Pagar.me (p√∫blico)
 */
export const paymentControllerHandleWebhook = (
    
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/payment/webhook`, method: 'POST', signal
    },
      options);
    }
  


export const getPaymentControllerHandleWebhookMutationOptions = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerHandleWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof http>}
): UseMutationOptions<Awaited<ReturnType<typeof paymentControllerHandleWebhook>>, TError,void, TContext> => {

const mutationKey = ['paymentControllerHandleWebhook'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof paymentControllerHandleWebhook>>, void> = () => {
          

          return  paymentControllerHandleWebhook(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PaymentControllerHandleWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof paymentControllerHandleWebhook>>>
    
    export type PaymentControllerHandleWebhookMutationError = ErrorType<unknown>

    /**
 * @summary Receber notifica√ß√µes de webhook do Pagar.me (p√∫blico)
 */
export const usePaymentControllerHandleWebhook = <TError = ErrorType<unknown>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof paymentControllerHandleWebhook>>, TError,void, TContext>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof paymentControllerHandleWebhook>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getPaymentControllerHandleWebhookMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * @summary Listar todos os produtos (p√∫blico)
 */
export const productControllerFindAll = (
    params: ProductControllerFindAllParams,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/products`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getProductControllerFindAllQueryKey = (params?: ProductControllerFindAllParams,) => {
    return [
    `http://localhost:3000/products`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getProductControllerFindAllQueryOptions = <TData = Awaited<ReturnType<typeof productControllerFindAll>>, TError = ErrorType<unknown>>(params: ProductControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductControllerFindAllQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productControllerFindAll>>> = ({ signal }) => productControllerFindAll(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductControllerFindAllQueryResult = NonNullable<Awaited<ReturnType<typeof productControllerFindAll>>>
export type ProductControllerFindAllQueryError = ErrorType<unknown>


export function useProductControllerFindAll<TData = Awaited<ReturnType<typeof productControllerFindAll>>, TError = ErrorType<unknown>>(
 params: ProductControllerFindAllParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof productControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductControllerFindAll<TData = Awaited<ReturnType<typeof productControllerFindAll>>, TError = ErrorType<unknown>>(
 params: ProductControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productControllerFindAll>>,
          TError,
          Awaited<ReturnType<typeof productControllerFindAll>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductControllerFindAll<TData = Awaited<ReturnType<typeof productControllerFindAll>>, TError = ErrorType<unknown>>(
 params: ProductControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Listar todos os produtos (p√∫blico)
 */

export function useProductControllerFindAll<TData = Awaited<ReturnType<typeof productControllerFindAll>>, TError = ErrorType<unknown>>(
 params: ProductControllerFindAllParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindAll>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductControllerFindAllQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Buscar produto por ID (p√∫blico)
 */
export const productControllerFindById = (
    id: string,
 options?: SecondParameter<typeof http>,signal?: AbortSignal
) => {
      
      
      return http<void>(
      {url: `http://localhost:3000/products/${id}`, method: 'GET', signal
    },
      options);
    }
  



export const getProductControllerFindByIdQueryKey = (id?: string,) => {
    return [
    `http://localhost:3000/products/${id}`
    ] as const;
    }

    
export const getProductControllerFindByIdQueryOptions = <TData = Awaited<ReturnType<typeof productControllerFindById>>, TError = ErrorType<unknown>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof http>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getProductControllerFindByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof productControllerFindById>>> = ({ signal }) => productControllerFindById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ProductControllerFindByIdQueryResult = NonNullable<Awaited<ReturnType<typeof productControllerFindById>>>
export type ProductControllerFindByIdQueryError = ErrorType<unknown>


export function useProductControllerFindById<TData = Awaited<ReturnType<typeof productControllerFindById>>, TError = ErrorType<unknown>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof productControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof productControllerFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductControllerFindById<TData = Awaited<ReturnType<typeof productControllerFindById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof productControllerFindById>>,
          TError,
          Awaited<ReturnType<typeof productControllerFindById>>
        > , 'initialData'
      >, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useProductControllerFindById<TData = Awaited<ReturnType<typeof productControllerFindById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Buscar produto por ID (p√∫blico)
 */

export function useProductControllerFindById<TData = Awaited<ReturnType<typeof productControllerFindById>>, TError = ErrorType<unknown>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof productControllerFindById>>, TError, TData>>, request?: SecondParameter<typeof http>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getProductControllerFindByIdQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
